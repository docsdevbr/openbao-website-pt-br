---
# Copyright (c) 2026 OpenBao a Series of LF Projects, LLC.
# Copyright (c) 2015 HashiCorp, Inc.
#
# Documentation licensed under the Mozilla Public License 2.0.
# The original work was translated from English into Brazilian Portuguese.
# https://github.com/openbao/openbao/blob/-/LICENSE

source_url: https://github.com/openbao/openbao/blob/release/2.5.x/website/content/docs/internals/architecture.mdx
revision: e2d983ae2d1c12cf83887e1899ee1b0fb98373d9
status: ready

description: Aprenda sobre a arquitetura interna do OpenBao.
---

# Arquitetura

O OpenBao é um sistema complexo com diversos componentes distintos.
Esta página detalha a arquitetura do sistema e visa auxiliar pessoas usuárias e
desenvolvedoras do OpenBao a construir um modelo mental enquanto compreendem a
teoria de operação.

:::warning

**Nota:** Esta página aborda os detalhes técnicos do OpenBao.
As descrições e os elementos aqui contidos destinam-se a pessoas usuárias que
desejam aprender sobre o OpenBao sem precisar consultar o código-fonte.
Embora não seja obrigatório, recomendamos que todas as pessoas usuárias e
operadoras revisem as informações fornecidas antes de usar o OpenBao, devido à
sua importância em um ambiente.

:::

## Visão geral de alto nível

O diagrama abaixo ilustra as complexidades e os componentes distintos do
OpenBao.

[![Visão geral da arquitetura](/img/layers.png)](/img/layers.png)

A camada de criptografia do OpenBao, chamada de _barreira_, é responsável por
criptografar e descriptografar os dados do OpenBao.
Quando o servidor OpenBao é iniciado, ele grava dados em seu backend de
armazenamento.
Como o backend de armazenamento reside fora da barreira, ele é considerado não
confiável, portanto, o OpenBao criptografa os dados antes de enviá-los para o
backend de armazenamento.
Esse mecanismo garante que, se uma pessoa invasora maliciosa tentar obter acesso
ao backend de armazenamento, os dados não poderão ser comprometidos, pois
permanecerão criptografados até que o OpenBao os descriptografe.
O backend de armazenamento fornece uma camada de persistência de dados durável,
onde os dados são protegidos e disponíveis mesmo após reinicializações do
servidor.

Quando um servidor OpenBao é iniciado, ele começa em um estado _selado_.
Antes de qualquer operação ser realizada no OpenBao, o _selo deve ser retirado_.
Isso é feito fornecendo as chaves de retirada de selo.
Durante a inicialização do OpenBao, ele gera uma chave de criptografia, usada
para proteger todos os dados do OpenBao.
Essa chave é protegida por uma chave raiz armazenada com todos os outros dados
do OpenBao, mas criptografada por outro mecanismo: a chave de retirada de selo.

Por padrão, o OpenBao usa o
[Compartilhamento de segredo de Shamir](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing)
para dividir a chave de retirada de selo em um número configurado de fragmentos
(partes da chave ou chaves de retirada de selo).
Um número preciso de fragmentos é necessário para reconstruir a chave de
retirada de selo, que é então usada para descriptografar a chave raiz do
OpenBao.

![Chaves de retirada de selo](/img/openbao-shamir-seal.png)

Consulte a documentação de
[Selar/Retirar selo](../concepts/seal.mdx#seal-unseal) para obter mais detalhes.

O número de partes e o número mínimo de fragmentos necessários podem ser
especificados.
A técnica de Shamir pode ser desativada e a chave raiz pode ser usada
diretamente para a retirada de selo.
Assim que o OpenBao recupera a chave de criptografia, ele descriptografa os
dados no backend de armazenamento e entra no estado _sem selo_.
Uma vez sem selo, o OpenBao carrega os dispositivos de auditoria, os métodos de
autenticação e os mecanismos de segredos configurados.

:::warning

**Observação:** A configuração padrão do OpenBao usa um selo de Shamir; no
entanto, o OpenBao pode ter o
[selo retirado automaticamente](../concepts/seal.mdx#auto-unseal) por um sistema
de gerenciamento de chaves em nuvem (KMS) ou módulo de segurança de hardware
(HSM) confiável para aumentar a segurança.

:::

A configuração dos dispositivos de auditoria, métodos de autenticação e
mecanismos de segredos é sensível à segurança e é armazenada no OpenBao.
Pessoas usuárias com permissões podem modificá-las e não podem ser especificadas
fora da barreira.
Ao armazená-las no OpenBao, as alterações são protegidas pelo sistema ACL e
rastreadas por logs de auditoria.

As requisições podem ser processadas da API HTTP para o núcleo assim que o selo
do OpenBao for retirado.
O núcleo gerencia o fluxo de requisições pelo sistema, aplica ACLs e garante que
o registro de auditoria seja feito.

Quando um cliente se conecta ao OpenBao pela primeira vez, ele precisa se
autenticar.
O OpenBao fornece métodos de autenticação configuráveis e oferece flexibilidade
no mecanismo de autenticação usado.
Mecanismos como nome de usuário/senha ou GitHub podem ser usados para pessoas
operadoras, enquanto as aplicações podem usar chaves públicas/privadas ou tokens
para se autenticar.
Uma requisição de autenticação que flui pelo núcleo e para um método de
autenticação determina se a requisição é válida e retorna uma lista de políticas
associadas.

As políticas são simplesmente regras ACL nomeadas.
Por exemplo, a política "root" é integrada e permite o acesso a todos os
recursos.
Você pode criar qualquer número de políticas nomeadas com controle preciso sobre
os caminhos.
O OpenBao opera em modo de acesso permitido, o que significa que a ação não é
permitida a menos que o acesso seja concedido explicitamente por meio de uma
política.
Como um usuário pode ter várias políticas associadas, as ações são permitidas
quando a política o permite.
As políticas são armazenadas e gerenciadas por um repositório de políticas
interno.
Esse repositório interno é afetado pelo backend do sistema, que é sempre montado
em `sys/`.

Assim que a autenticação ocorre e um método de autenticação fornece um conjunto
de políticas aplicáveis, um novo token de cliente é gerado e gerenciado pelo
repositório de tokens.
Esse token de cliente é usado para fazer requisições futuras.
Esse método de token é semelhante a um cookie enviado por um site quando uma
pessoa usuária faz login.
Dependendo da configuração do método de autenticação, o token de cliente pode
ter um período de concessão associado a ele e pode precisar ser renovado
periodicamente para evitar a invalidação.

Após a autenticação, as requisições são feitas fornecendo o token do cliente.
O token do cliente é usado para verificar o cliente, garantindo que ele esteja
autorizado durante o carregamento das políticas relevantes.
As políticas são usadas para autorizar a requisição do cliente.
A requisição é então roteada para o mecanismo de segredos, que é processado
dependendo do seu tipo.
Quando o mecanismo de segredos retorna o segredo, o núcleo o registra com o
gerenciador de expiração e anexa um ID de concessão.
Os clientes usam o ID de concessão para renovar ou revogar seu segredo.
O gerenciador de expiração revoga automaticamente o segredo se um cliente
permitir que a concessão expire.

O núcleo registra requisições e respostas no agente de auditoria, distribuindo
as requisições para todos os dispositivos de auditoria configurados.
Fora do fluxo de requisições, o núcleo executa atividades específicas em segundo
plano.
O gerenciamento de concessões é crucial, permitindo que tokens ou segredos de
clientes expirados sejam revogados automaticamente.
Além disso, o OpenBao lida com casos específicos de falha parcial usando o
registro de log antecipado com um gerenciador de reversão.
Isso é gerenciado de forma transparente no núcleo e não é visível para a pessoa
usuária.

## Recursos

- Para saber mais sobre cada componente e subsistema do OpenBao, selecione um
  tópico no menu de navegação à esquerda.
- Para detalhes aprofundados, consulte o código.
